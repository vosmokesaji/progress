FrontEnd Interview

# PLAN
- [ES6](http://es6.ruanyifeng.com/#README) 周一，周二两天
- [VUE](https://cn.vuejs.org/v2/guide/) [面试题](https://juejin.im/post/5d218f6751882579d9188eeb?utm_source=gold_browser_extension)  周三周四两天
- [webpack](https://www.webpackjs.com/concepts/) 周五一天
- [网络知识](https://juejin.im/post/5c591fda6fb9a049dc02b1cc)、[这些](https://juejin.im/search?query=%E5%89%8D%E7%AB%AF%20%E7%BD%91%E7%BB%9C&type=all)、[布局](https://juejin.im/post/5b3b56a1e51d4519646204bb)  周末

# Point
- CSRF 是啥？

# 直播课程

## 珠峰培训精品公开课：浏览器渲染原理
0. 介绍 
- 真正的前端开发，对js低层，浏览器运行底层，有清楚的了解，写出来的代码在性能、稳定、可扩展性更强，更多大声直接封装底层框架。

1. 浏览器渲染机制
   1. HTTP请求阶段
   2. HTTP响应阶段
   3. 浏览器渲染阶段


2. 阿里经典面试题：DOM重回和回流



3. 阿里九段人才培养方案



4. 当下前端开发工程师需要掌握的技术栈



5. 给自学者的建议




## andorcba
重要的放上面：
	https://coding.imooc.com/class/190.html
	我在慕课上买的课要看就用我的微信登录

项目
	技术栈
	业务深度
	成长

webpack 分包优化 性能优化
es6
	箭头函数的作用
	扩展符的应用(...)
	promise
		实现原理    https://www.jianshu.com/p/b4f0425b22a1
		解决了什么问题  https://blog.csdn.net/weixin_34114823/article/details/88741050
	什么是事件循环   https://www.jianshu.com/p/8df1d01b33dc
	什么是宏任务和微任务  https://www.jianshu.com/p/8df1d01b33dc
	Async wait / promise区别    http://caibaojian.com/asyncawait.html
	Class的实现原理   https://segmentfault.com/a/1190000008390268?utm_source=tag-newest

vue
	组件间通信(子-父，父-子，兄弟间)
	computed watch差别
	keep-alive生命周期activated和deactivated的理解
	vuex 的api及使用场景
	vuex中actoin和mutation的差别
	vue-router钩子函数
	如何封装组件
	snabodom的核心方法
	MVVM的理解  https://coding.imooc.com/class/190.html
	什么是虚拟DOM  https://coding.imooc.com/class/190.html
	vue如何双向绑定 ：definePropoty + 订阅式  https://coding.imooc.com/class/190.html
	vue性能为何高于jQuery?
原生JS
	如何实现原型继承
	内存泄漏 
	回收机制 
	闭包 
	call apply使用场景
	判断数组方法
	数组的常用方法
	jQuery实现原理   https://www.jianshu.com/p/ca9825766db3
	弱类型间的转换
	设计模式  https://www.jianshu.com/p/4b110e4c3bcd
		工厂模式
		构造函数模式
		原型模式
		单例模式
		发布者模式 + 订阅者模式
		观察者模式
	requestAnimationFrame  与 setTimeout 差别
	ajax实现原理
	0.1+0.2>0.3  成立吗？为什么


浏览器知识
	浏览器解析原理  https://blog.csdn.net/riddle1981/article/details/78681191
	跨域解决办法 https://segmentfault.com/a/1190000015597029
	什么是同源策略
	v8是什么
	浏览器内核种类
	回流和重绘  https://segmentfault.com/a/1190000014474575
	性能优化相关
	存储   https://www.jianshu.com/p/03a38b56bdd7
		localstorage
		sessionstorage
		cookie
		user data
		以上的区别
	缓存    https://www.jianshu.com/p/54cc04190252
		物理缓存
		内存缓存
		强缓存缓存
		以上的区别
相关知识
	7层网络协议   https://blog.csdn.net/taotongning/article/details/81352985
	http协议 及 https相关知识理解   https://www.jianshu.com/p/6db0c6dc97a9
	http code码   https://blog.csdn.net/qq_35779969/article/details/80753197
算法、数据结构
	快排 
	冒泡
	生成一个任意区间的随机数
	url字典对象    https://blog.csdn.net/redtopic/article/details/69396908
	实现抽奖 ： 尽可能实现一个均匀的正态分布：每一百次中 一等奖1个 二等奖10个三等奖20 剩余未中奖
	什么是堆和栈    https://blog.csdn.net/flyingpig2016/article/details/52895620
	直接类型和引用数据类型的区别  https://www.cnblogs.com/chunyi/p/10281750.html

页面类
	rem布局h5中设置基础的font-size是如何换算的  https://www.jianshu.com/p/04efb4a1d2f8
	webp是什么
动画/css
	transtion 和 transform的应用场景和差别  https://segmentfault.com/a/1190000016666601
	如何开启GPU加速  https://blog.csdn.net/hsany330/article/details/50925260

概念性
	什么是工程化 模块化 组件化   https://www.jianshu.com/p/8cad6f0b94b3
	amd、cmd、commonjs规范 区别及应用   https://www.cnblogs.com/jiuyi/p/9181259.html
	前端语义化   https://www.jianshu.com/p/81b264b179bf
	行为结构表现分离



相关资料：
1. JS ES6语法: 1. var let const区别（https://baijiahao.baidu.com/s?id=1621787284851612777）。 
2. 箭头函数相关（包括里面的this等）（https://www.cnblogs.com/fundebug/p/6904753.html、https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001438565969057627e5435793645b7acaee3b6869d1374000、https://blog.csdn.net/hqh642134542/article/details/78809951）3. Promise原理（https://baijiahao.baidu.com/s?id=1596005633332556077）
2. 网络方面：1. 网络7层协议（https://www.cnblogs.com/qishui/p/5428938.html、https://blog.csdn.net/cmyh100/article/details/82768804） 2. xhr(http://www.cnblogs.com/xiaohuochai/p/6036475.html)以及fetch(https://www.jianshu.com/p/35123b048e5e) 3. 跨域(https://segmentfault.com/a/1190000015597029) 4. HTTP code(https://blog.csdn.net/qq_35779969/article/details/80753197)
3. 浏览器相关：1. 缓存原理（https://www.cnblogs.com/shixiaomiao1122/p/7591556.html） 2. 从访问一个URL到用户看见页面之间所有的过程（https://www.jianshu.com/p/01d25c206fab） 3. 浏览器渲染原理（JS引擎，CSS引擎等）(https://blog.csdn.net/riddle1981/article/details/78681191)
4. 性能方面：https://www.jianshu.com/p/a29aadf28a9e
5. 组件方面：http://web.jobbole.com/92879/、https://www.cnblogs.com/kuailingmin/p/4205724.html
6. 工程化：https://www.cnblogs.com/fsyz/p/8274727.html、https://www.imooc.com/article/48008
7. 面向对象方面：https://blog.csdn.net/jsnancy/article/details/80357188、https://www.cnblogs.com/chenhuichao/p/8202588.html
8. 观察者模式：https://www.cnblogs.com/gradolabs/p/4786782.html

https://www.cnblogs.com/c2016c/articles/9328725.html
https://www.cnblogs.com/le220/p/8624905.html
https://www.jianshu.com/p/deceb72e13b3
https://www.jianshu.com/p/deceb72e13b3
https://www.cnblogs.com/minigrasshopper/p/9134196.html
https://blog.csdn.net/wulex/article/details/81774494  https://www.jianshu.com/p/eef79060d486  https://www.cnblogs.com/hahazexia/p/8691052.html  理解call apply bind
https://blog.csdn.net/MingL520/article/details/88549999    面试题汇总
https://www.jianshu.com/p/0d50ea1cef93?utm_source=oschina-app   vue声明周期
https://www.cnblogs.com/jiasm/p/9482443.html    微任务、宏任务
https://www.jianshu.com/p/df198914331b  vue首屏加载优化


# 慕课前端面试课


## ES6 语法

- 开发环境已经普及使用
- 浏览器确支持不好（需要开发环境编译）
- es6 内容很多，重点了解常用语法
- 面试： 开发环境的使用 + 重点语法的掌握

### 问题
- ES6 模块化如何使用，开发环境怎么打包
- Class 和普通构造函数有何区别
- Promise 的基本使用和原理
- 总结一下 ES6 的常用功能

### 模块化

1. 模块化 - 语法
```javascript
/* util1.js */
export default {
    a: 100
}

/* util2.js */
export function fn1() {
    alert("fn1");
}
export function fn2() { 
    alert("fn2");
}

/* index.js */
import util1 from './util1.js';
import { fn1, fn2 } from './util2.js';
console.log(util1);
fn1();
fn2();

// 如果用的是 export default ，引入的时候直接 import 就行
// 如果是 export 好几个，引入的时候要用大括号括起来，像这样  { fn1, fn2 } ，哪怕只有一个也要放在大括号里  { fn1 } 
```

2. ES6 语法解析： babel
- 电脑中要有 node 环境， 运行 
    ```shell
    npm init
    # 或者
    npm init -y

    # 安装 babel
    npm install --save-dev babel-core babel-preset-es2015 babel-preset-latest
    # 或者这样  （ 注_001 ） 
    npm install --save-dev babel-core babel-preset-es2015 babel-preset-latest --registry=https://registry.npm.taobao.org
    
    # 创建 .babellrc 文件
    touch .babelrc

    # 全局安装 babel-cli （ mac 全局安装需要 sudo ； windows 全局安装需要以管理员身份运行命令行工具 ，再执行这个）
    npm install -global babel-cli

    # 看 babel 是否安装成功
    babel --version
    ```
- 创建 index.js 
    ```javascript
    [1, 2, 3].map(item => item + 1);
    ```
- 编译 index.js
    ```shell
    babel index.js
    ```
- 注_001：这里安装的时候为了快，可以走[国内镜像](https://npm.taobao.org)
- .babelrc 文件的内容： ```"es2015", "latest"``` 是我们刚刚安装两个插件的别名， ```"plugins"``` 是插件，暂时不用
    ```json
    {
        "presets": ["es2015", "latest"],
        "plugins": []
    }
    ```
- .babelrc 不用太详细的了解，是 #$%^&*()*&^% (记助攻对 的一部分？ 没听清)

3. 打包工具： webpack 
- 安装
    ```shell
    # 建议在项目内安装 webpack 
    npm webpack babel-loader --save-dev
    ```
- webpack 配置文件 webpack.config.js
    ```javascript
    module.export = {
        entry: "./src/index.js",
        output: {
            path: __dirname,
            filename: "./build/bundle.js"
        },
        module: {
            rules: [{
                test: /\.js?$/,
                exclude: /(node_modules)/,
                loader: "babel-loader"
            }]
        }
    }
    ```
- 配置 package.json 中的 ```scripts``` 
    ```json
    "scripts": {
        "start": "webpack"
    }
    ```
- 运行 ```npm start``` 其实就相当于运行 ```"scripts"``` 里 ```"start"``` 对应的 ```"webpack"``` 
- webpack 会根据我们配置好的 webpack.config.json 进行打包
- 打包完之后，可以测试一下：
    1. 创建一个 index.html ，引入 src/bundle.js 
    2. 开启服务：命令行在 index.html 所在目录运行 ```http-server -p 8881```
    3. 浏览器访问 [localhost:8881/index.html](http://localhost:8881/index.html)
    4. 会看到 页面 alert 了 fn1 fn2 ，控制台输出了 ```{a: 100}``` ， 说明 util1 和 util2 都被 webpack 打包到了 bundle.js 中了

4. rollup
- vue 和 React 框架都是通过 [rollup](https://rollupjs.org/guide/zh/) 打包的 （这里是[英文网站](https://rollupjs.org/guide/en/)）
- 重新搞一个文件夹，来学习 rollup 
    ```shell
    mkdir learnRollup && cd learnRollup
    npm init 

    # 安装 rollup 以及 rollup 需要的一些工具
    npm install rollup rollup-plugin-node-resolve rollup-plugin-babel babel-plugin-external-helpers babel-preset-latest babel-core --save-dev
    
    # 创建 .babelrc
    touch .babelrc

    # 创建 rollup 配置文件
    touch rollup.config.js
    ```
- .babelrc 的内容
    ```json
    {
        "presets": [
            ["latest", {
                "es2015": {
                    "modules": false
                }
            }] 
        ],
        "plugins": ["external-helpers"]
    }
    ```
    - 不一样的地方： ```"modules": false``` 意思是我们不关心引入的第三方插件， ```"external-helpers"``` 因为 rollup 使用 babel 的时候依赖这么一个插件
- rollup.config.js 的内容
    ```javascript
    // 引入 babel 和 resolve 这两个插件
    import babel from "rollup-plugin-babel";
    import resolve from "rollup-plugin-node-resolve";

    export default {
        entry: "./src/index.js",        // 入口文件
        format: "umd",                  // 格式： umd 意思是即兼容 直接引入页面中的 js ，也兼容 CommenJS ， 也兼容 AMD
        plugins: [
            resolve(),
            babel({
                exclude: "node_modules/**"
            })
        ],
        dest: "build/bundle.js"
    }
    ```

- 将 webpack 环境的代码拷贝过来
- 修改 package.json 的 ```scripts``` 
    ```json
    "scripts": {
        "start": "rollup -c rollup.config.js"
    }
    ```
- 运行 ```npm start``` 
- 将打包的结果对比 webpack ，我们发现：
    1. rollup 打包的代码跟简洁，冗余代码更少，基本和源码一样，方便调试
    2. rollup 打包的文件体积比 webpack 的要小


5. rollup 对比 webpack
- rollup 功能单一 （专注打包）， webpack 功能强大（学习成本很高）
- 参考设计原则和《Linux/Unix设计思想》，这两本书都提到了 “单一值原则” ，一个东西做好一件事儿就好了
- 工具要劲量功能单一，可集成，可扩展
- wangEditor 用的 gulp + rollup （ [wangEditor](https://github.com/wangfupeng1988/wangEditor) 是作者的一个开源项目）


6. 总结 关于 JS 众多模块化标准
- 没有模块化的时候，代码冗余严重
- AMD 成为**标准**， require.js （也有 CMD ，用的不是特别多）
- 前端打包工具，grunt -> gulp -> webpack  ， nodejs 模块也可以被使用
- ES6 出现，想统一现在所有模块化的标准
- nodejs 积极支持，浏览器尚未统一
- 你可以自造 lib ， 但是不要自造标准！！！

7. 总结 & 问题解答
- 语法： import export （ 注意有无 default ）
- 环境：babel 是用来编译 ES6 语法的， 模块化可以用 webpack 和 rollup 
- 扩展：说一下自己对模块化标准统一的期待


### Class

> 2-9 开始于 3点20  开会浪费了半个小时

#### Class 和 普通构造函数有何区别
- JS 构造函数 
- Class 基本语法
- 语法糖
- 继承 


1. JS 构造函数
    ```javascript
    function MathHandle(x, y){
        this.x = x;
        this.y = y;
    }

    MathHandle.prototype.add = function(){
        return this.x + this.y;
    };

    var m = new MathHandle(1, 2);
    console.log(m.add());
    ```

2. Class基本语法
    ```javascript
    class MathHandle {
        // constructor 是一个构造器，相当于构造函数
        constructor(x, y) {
            this.x = x;
            this.y = y;
        }

        // 相当于在原型中定义的方法
        add(){
            return this.x + this.y;
        }
    }

    const m = new MathHandle(1, 2);
    console.log(m.add());

    typeof MathHandle;   // "function"
    MathHandle === MathHandle.prototype.constructor;    // true

    // 实例的 隐式原型 等于 构造函数的 显式原型
    m.__proto__ === MathHandle.prototype;       // true
    ```

3. 语法糖 （这两种写法，本质是一样的， calss 相当于语法糖，书写更加简单，更方便从后端转前端的开发）
    ```javascript
    class MathHandle {}

    typeof MathHandle;   // "function"
    MathHandle === MathHandle.prototype.constructor;    // true
    m.__proto__ === MathHandle.prototype;       // true

    // 这种语法糖形式，看起来和实际原理不一样的东西，视频老师个人不太赞同
    // 形式上强行模仿 java C# ， 却失去了它的本性和个性
    ```
4. class 继承
- 回顾一下 JS 的继承
    ```javascript
    // 动物
    function Animal(){
        this.eat = function(){
            console.log("animal eat");
        }
    }

    // 狗
    function Dog(){
        this.bark = function(){
            console.log("dog bark");
        }
    }

    // 绑定原型，实现继承 （这里视频的老师没有将 构造函数 重新指向 Dog ，应该是要有这么一步的）
    Dog.prototype = new Animal();

    // 实例化 哈士奇
    var hashiqi = new Dog();
    ```

- class 继承
    ```javascript
    class Animal {
        constructor(name){
            this.name = name;
        }

        eat(){
            console.log(this.name + "eat");
        }
    }

    class Dog extends Animal {
        constructor (name){
            // 注意 ！！！ 只要这个 class 有 extends 就得败 super 写上
            // super(name) 相当于执行了被继承的 class 的 constructor ，并且把 name 传了进去
            super(name);
            this.name = name;
        }

        say(){
            console.log(`${this.name} say`);
        }
    }

    const dog = new Dog("哈士奇");
    dog.say();
    dog.eat();
    ```
- class 写继承 相较于 构造函数的继承，可读性更强，更方便初学者   

5. 总结
- Class 在语法上更加贴合面向对象的写法
- Class 实现继承更加易读、易理解
- 更易于写 java 等后端语言的使用
- **本质**还是语法糖，使用 prototype 
- 所有的语法糖都需要了解本质

### Promise 
- Callback Hell (回调地狱)
    ```javascript
    function loadImg(src, callback, fail){
        var img = document.createElement("img");
        img.onload = function(){
            callback(img);
        }
        img.onerror = function(){
            fail();
        }
        img.src = src;
    }

    var src = "https://www.imooc.com/static/img/index/logo.png";
    loadImg(src, function(img){
        console.log(img.width);
    }, function(){
        console.log("failed")
    });
    ```
- Promise 语法
    ```javascript
    function loadImg(src){
        // 创建 Promise 实例
        // resolve （解决） 和 reject  （拒绝） 都是函数，分别是成功和失败的回调
        const promise = new Promise(function(resolve, reject){
            var img = document.createElement("img");
            img.onload = function(){
                resolve(img);
            }
            img.onerror = function(){
                reject();
            }
            img.src = src;
        });

        // return Promise 实例
        return promise;
    }

    // 使用
    var src = "https://www.imooc.com/static/img/index/logo.png"
    var result = loadImg(src);

    // 第一个 function : 成功的回调， 第二个 function ： 失败的回调
    result.then(function(img){
        console.log(img.width);
    }, function(){
        console.log("failed");
    })

    // 一个 Promise 对象可以分开处理不同的事件
    result.then(function(img){
        console.log(img.height);
    });

    // 多个 then 可以处理不同的回调，一次干多件事儿 
    ```
- 小结一下 Promise 的用法：
    - 创建 Promis 实例，传入一个回调函数，函数要有 resolve 和 reject 这两个参数
    - 在这个回调函数里你可以定义什么情况执行 resolve （一般是成功）， 什么情况执行 reject （一般是失败）
    - 使用 Promise 实例的 .then() 监听结果，处理相应的 成功回调 或者 失败回调




### ES6 其他常用功能

- let/const
    - let 定义变量
    - const 定义常量（只能赋值一次，再次赋值会报错）
- 多行字符 / 模板字符串
    ```javacript

    ```
- 解构赋值
- 块级作用域
- 函数默认参数
- 箭头函数 

> 这些功能要么是解决了 JS 的问题，要么是让写法更简洁，容易阅读容易理解




## 原型



## 异步



## 虚拟 DOM



## MVVM 和 vue



## 组件化和 React



## hybrid



## 总结






























