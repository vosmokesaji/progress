# 斯坦福大学开放课程： 编程方法
<!-- 
2007年的课程
http://www.class.cn/course/course_detail?course_id=100104 
-->

> 课程名称： Programming Methodology <br>
> 课程编号： CS 106A <br>
> 主讲： Mehran Sahami （麦兰·萨哈米）


## 第一课

### 课程简介

- 将了讲义的事儿，没拿也不用担心，下课了可以去拿，保够
- 做了个统计：大家对计算机的熟悉程度
- 说明了这是公开课，会被放到网上供全世界的人观看，以及对在座各位的影响
- 介绍自己：称呼不要太正式，叫麦兰就好，和睦相处其乐融融
- 编程方法教授的诗良好的软件工程思想，比单纯的编程范围大得多
- 学习如何编程和成为一个好作家差不多
- 帮助**不同类型**的学生摆脱顾虑（ 这么贴心的老师，学生也太幸福了 ）
- 配备了很多教员
- 竞争对象不是同学，而是自己
- 关于讲义，[课程讲义](https://web.stanford.edu/class/cs106a/) or [课程讲义](http://cs106a.stanford.edu/) ，为了防止学生没有领取到纸质讲义（ 第二个网址是为了方便学生记忆，斯坦福真贴心，做了一个 302 跳转 ）
- 注册系统，等等，系统都使用邮件通知（我在想中国，可以使用微信公众号等方法 ）
- 关于作业：
    - 提前说明了有 7 次作业，讲义上都有明确的截止日期
    - Eclipse（ 如果你有电脑，课程网页上有安装教程，mac & pc ；如果你没有电脑，可以用学校的，已经预装了 Eclipse 无论哪种方式都很简单 ）
- 如何保证你能真正学到东西？
    - 交上来的作业不会给你打个 A 或者 B 
    - 作业上交后，小组长会仔细批阅评分
    - 每周都要和小组长交流 10 到 15 分钟
    - 这叫做互动评分，只一个与人交流的好机会
    - 可以交流作业中的闪光点、需要改进的地方、编程思想、还有哪些欠缺；
    - 这样你就能获得更详细的信息，也可以提出一些疑难问题，如需帮助，尽管开口
- 在斯坦福什么都是越精简越好
- 讲解了评分等级
    - 最优秀的评分（ ++ ），需要小组长和老师商讨；
    - 同样，你拿到 -- 的时候，老师也会自责；
    - 没交作业得 0 分
- 宽限日，两天，需要提前申请，不鼓励使用，3天后不收作业
- 两次考试：期中，期末
    - 如果时间有冲突可以发邮件给老师，老师会综合考虑大家而时间安排，决定要不要调整考试时间
    - 作业：45% ； 期中： 15% ； 期末： 30% ； 平时成绩：10% （有没有定期参加讨论小组，有没有互助评分，有没有逃过课）
- 坐在前边的有糖
- 老师不是很严肃的人，但是有一件事会非常严肃，而且整个斯坦福都会很严肃：
    - 学术剽窃和行为准则 
    - 有谁和他扯上关系，会有一大群人找你麻烦 
    - 行为准则：
        - 鼓励交流
        - 鼓励在课堂上讨论各种想法
        - 讨论解决问题的策略
        - 鼓励提出问题
        - 最终在课堂上解决难题
    - 界限在哪里：
        - 不要共享代码 Don't share code.  可以讨论，但是代码要你自己写。 
        - 注明出处
        - 有工具能自动对比代码，对比你和其他同学的，你和往届同学的，绝对准确无误。
        - 不要因为**一念之差**，犯错
- 学生提问：（问一个问题给一颗糖） 
    - 迟交作业的惩罚：迟一天，作业评分降一级
    - 分讨论小组是先选先得吗，是的
    - 安排多少时间？斯坦福通常的课程要安排**课程的单元数乘以三**

### 编程入门简介
- BUG 
    - 短接了计算机电路的飞蛾
    - DEBUG ： 解决机械设备故障
- 误区：
    1. 仅仅学习语言本身的特性，认为只要学好语言就能成为一个好的软件工程师
    2. 过于关注语言的细节，对程序设计却没有宏观的把握
- 改变：瑞奇·帕提斯：
    - 教授的计算机入门课程时，能不能把各种语言的繁杂指令放在一边
    - 先从最简单的教起，以便学生能更快的学习各种指令
    - 这样大家就具备了掌握程序设计语言的基本素养
    - 可以把主要精力放在**软件工程思想**方便面
    - 事实证明这个想法很天才
- 卡雷尔机器人（ Karel the Robot ）：
    - 名字来自于 卡雷尔·恰派克 （ Karel Capek ） 
        - 捷克的小说家
        - 他创造了机器人（ robot ） 这个词
        - 他曾写过一本有关机器人的小说 R.U.R （《Rur Rossum's Universal Robots》）
        - 机器人这个词来自捷克语，意思是 “工作” 
        - 因此我们的机器人就用 卡雷尔 命名了，有时也会叫 卡尔

> 第一节课： 讲师一直在说的一句话：巴拉巴拉，don't worry...  巴拉巴拉， No worries, okay? 



## 第二课 欢迎来到 Karel 的世界
- 指令
- move 
- turnLeft  ( 一个词，没有空格 )
- pickBeeper
- putBeeper
- 以上这些我们称之为，方法（ methods ），就是可以调用或使用的指令，我们只需要调用方法，卡雷尔就能完成指定的动作
- 编程的艺术：解决问题的方法不止一个
- karel 移动的过程
    - move
    - pickBeeper
    - move
    - turnLeft
    - move
    - turnLeft
    - turnLeft
    - turnLeft
    - move
    - putBeeper
    - move
- 以上的过程并不是有效的的程序，而是**算法**，是做事情的步骤 
- 算法和程序的区别，算法是做事的步骤，程序则必须按照语言的规则，合法的组织语句
- 想要成功调用 karel 的方法，需要在方法名后加一对括号和一个分号
- 我们还要告诉 karel 从哪里开始运行，封装成名为 run 的方法
    ```java
    // 把事先定义好的跟卡雷尔有关的东西度拿出来
    import Satndford.karel.*;

    public class OutKarelProgram extends Karel {
        public void run(){      // 这个花括号表示，中间的内容都是 这个 run 方法的
            move();
            pickBeeper();
            move();
            turnLeft();
            move();
            turnLeft();
            turnLeft();
            turnLeft();
            move();
            putBeeper();
            move();
        }
        // 花括号中间的部分就是函数体
        // 通常添加 缩进提高可读性 

        private void turnRight() {
            turnLeft();
            turnLeft();
            turnLeft();
        }
    }
    ```

- 给 karel 创建一些我们想要的方法，比如 右转 （ turnRight ）

    ```java
    import Satndford.karel.*;

    public class OutKarelProgram extends Karel {

        // public 是公开的
        public void run(){

            move();
            pickBeeper();
            move();
            turnLeft();
            move();

            // 将三个 turnLeft(); 换成 turnRight(); 
            turnRight();

            move();
            putBeeper();
            move();
        }

        // 在这里添加 turnRight
        // private 是藏着掖着的，只有自己能调用
        // 除了 run 之外 ，可以随便起名字
        private void turnRight() {
            turnLeft();
            turnLeft();
            turnLeft();
        }

        // 你也可以用两个 turnRight();  相当于六次左转， 这并不是一个好方法 
        private void turnAround() {
            turnLeft();
            turnLeft();
        }

    }
    ```

- karel 还有一个超级版本， karel 有的他都有，还多了一个右转和转身的方法 

    ```java
    import Satndford.karel.*;

    // superKarel 包含了 turnRight 和 turnAround ， 可以直接使用
    public class OutKarelProgram extends superKarel {

        public void run(){
            move();
            pickBeeper();
            move();
            turnLeft();
            move();
            turnRight();
            move();
            putBeeper();
            move();
        }

    }
    ```


- 老师提出了一个哲学问题： 当代大学生堕落的原因是什么？
    - 散漫拖延
    - 睡觉
    - 闹钟重响
    - 如何重复？ ```for``` 循环

    ```java
    for ( int i = 0; i < 3; i++ ){
        // 循环体
        turnLeft();
    }

    // 循环次数
    ```

- ```while``` 循环

    ```java
    // 前方畅通 ， 就前进
    private void moveToWall(){
        while( frontIsClear ) {
            move();
        }
    }
    
    ```
- 只想验证一次 ```if else``` 语句

    ```java
    // 有方块 ， 就捡起一个
    private void moveToWall(){
        if( beepersPresent() ) {
            pickBeeper();
        }else{
            putBeeper();
        }
    }
    
    ```

- 如何让 karel 跨越障碍（跨栏）
    - 如果前方没有障碍，就前进，
    - 如果前方有障碍就越过去（越过去又是封装的方法），怎么越
        - 先爬上这个障碍，向上走
        - 然后越过他
        - 再向下走
        - 那怎么爬上爬下呢？（我们这个过程就是将程序不断分解）
> 编程时很重要的一点是：不仅要写出计算机能读懂的程序，更要**让人读的懂**  <br>
> 这点**非常重要**，是编程风格的重要体现，也是好软件的必备条件 <br>
> 能正常运行，但其他人读不懂的程序，是非常糟糕的软件工程产品，很多软件公司有这样的事儿 <br>
> 这是软件工程第一条重要原则

- 回到这个问题：怎么爬上爬下？
    - 左转（ turnLeft ）
    - 右边有障碍的条件下，前进（ move ）
    - 右边没有障碍的时候（意味着已经到达了顶端），右转（ turnRight ）
    - 前进一步（到达障碍的另一侧）（ move ）
    - 如何下来呢？
    - 右转（ turnRight ）
    - 前方没有障碍的条件下，前进（ move ）
    - 前方有障碍的情况下，左转（ turnLeft ）

> 考虑程序的**通用性**，这点非常重要。你不会指只想让程序只在一种情况下正确运行吧（除非明确指出只需在某种情况下运行） <br>
> 你得让你的程序通用化，根据**通用的原则**来设计，使其在**满足基本规则**的情况下**都能正确运行**



## 第三课 karel 与 java 

- 讲解了常见错误
    1. 多少人读过洗发水的说明？
        - 引出**死循环**，**完全正确的语法**，但是却不能按我们的**预期设想**运行
        - 和语法错误相比这种错误在程序中经常出现
        - 小故事：某家芯片广告：我们的处理器极快，执行一个死循环只需 2.5秒 （看到的人可能会哈哈大笑） ，真正搞笑的地方在于这些芯片有缺陷，如果满负荷运行就会过热融化，结果执行死循环确实只用了2.5秒，之后处理器就着火罢工了
    2. “缺一个” 错误（ off-by-one bug ： OBOB）
        - 它是指程序**少执行了一次**，还不容易看出来
        - 如果你的程序出现了这样的错误，不用觉的只有你才会犯错，很多合格的程序员也经常犯这样的错

- 讲解了注释：
    - 编程的重要原则之一是：不仅要让电脑看懂，还要让人看懂
    - 注释就是在程序中加上的解释，方便人阅读，而不会影响程序的执行
    - 建议在文件顶端加上注释，标注文件名，很程序功能的简短说明
    - 给每个方法都标注了 **前置条件** 和 **后置条件**

- 什么是分解
    - 提出接近生活的问题：你今天早上出门前做什么了？
        - 起床
        - 刷牙
            - 拿牙刷
            - 挤牙膏
            - 在牙齿上刷
                - 上刷
                - 下刷
                - 左刷
                - 右刷
        - 去卫生间
        - 穿衣服
    - 这样细化的过程叫逐步求精，直到细化到 **原语（ primitives ）**
    - 分解（ Decomposition ）
    - 自顶向下的设计方法（ top-down design ）
    - 自底向上的设计方法（ bottom-up design ），大部分程序员最初都是这么开始的 
    - 心理学家研究，程序员需要编100小时的程序才能完成 自底向上 -> 自顶向下 的转变
    - 少数情况下 自底向上 有些用处，而大部分情况下，从最抽象的级别开始，逐步细化的思维方式更加简单

- 算法：指的是做某事的方法 （来自于19世纪波斯数学家，Al-Khwarzizmi 听起来很像 algorithm ）

### 加倍 karel

- 问题：karel 面前的格子中有些方块，他需要将方块翻倍，再回到初始位置（前提是 karel 袋子中有无限多个方块）
    - 解法：因为 karel 没有计数器，只能通过别的办法来做
    - 在目标位置拾起一个方块
    - 向前走一步，放下两个方块
    - 如此往复直到，没有方块可以捡，再把两倍之后的方块搬回来
- 自顶向下的写法时，你可能会写一些不存在的方法，没关系，之后会补上的
- 如果习惯自底而上的思维方式，调用不存在的方法肯定会感觉到不舒服
- 用逐步求精的代码对比写成一坨的代码
    - 来说明软件工程很重要
    - 因为很多情况下需要对已有的代码进行修改，而不是从头开始写代码，要多出10倍的概率
    - 所以如果一开始代码没写好，就要花10倍的成本去修复它（有人认为实际情况可能更糟）
- 学生的提问，讲到了命名规范
    - 你想怎么用就怎么用，坚持一种风格就行
    - 驼峰式
- 如何分解？有不同的分解方法吗？
    - 如何分解的指导原则：
        1. 每个方法应该能解决一个问题
        2. 你大部分方法应该在 1 ~ 15 行（仅供参考）
        3. 好的方法名字
        4. 注释

### 清洁工 karel
- karel 的房子一团糟，到处都是方块，每个点至多有一个方块 
- karel 需要遍历整个房间，打扫干净，他可以在任何地方终止
- 学校里真是神奇，自己明明赚了，却还搞得跟吃亏上当了一样

## 第四课 计算机发展史
- 4000 年前，人们发明了第一个计算工具——算盘（可以完成一些基础算术）
- 19 世纪（1800's）：查尔斯·巴贝奇 提出了**差分机**，是一种可以自动做计算的方法（那个年代还没有硅），后来又发明了功能更强大的分析机，都是在他去世之后才造出来的
- 第一个程序员是一位叫做 达·拜伦（ Ada Byron ）的女人（ 是英国诗人 拜伦 的女儿 ），为分析机写了很多的程序
- 计算机史真正始于20世纪30年代（1930-1940），在爱荷华州，阿塔纳索 和 贝瑞 制造出了一台计算机
- 1946年，电子数字积分计算机（ ENIAC ）诞生
- 1971年，第一个微处理器问世，（ Intel 4004 ）
- 计算机科学：使用计算机解决问题的科学

### 计算机能识别什么呢？
- 0 和 1 （2进制）
- 机器语言：计算机能读懂的语言，01序列
- 高级语言：Java / C / C++ / BAISC / Fortran 等等 

- 怎么把高级语言转化成机器语言？
    - 翻译的过程就是编译，是由编译器完成的
    - 源代码 -> 编译器 -> 目标代码

- Java 的编译有些不同
    - Java 的编译有一部分是在虚拟机上运行的
    - Java 中的源文件，经过编译器的编译，出来的不是目标文件，而是一种叫类文件的玩意儿（ 一系列的数值指令，而非计算机明白的二进制指令，有时 称之为 Java bite code ），汇集成 Java 存档文件（ jar ）
    - 这些指令人也看不懂（世界上还是有些人能看懂的），计算机也看不懂，会进入 Java 虚拟机（ JVM ）
    - JVM 把 jar 当成他的目标代码，把它当成最基本的语言，有了它我就可以在你的电脑上做事情
    - 你一定有疑问：为什么要这个多余的过程？
        - 原因在于，全世界的计算机有不同的系统：MacOS、Windos、Linux，这些电脑能识别的二进制指令是不一样的
        - 如果想要生成这些系统能识别的指令，编译器必须每种都知道
        - Java 不需要，中间语言 （ jar ） 对所有计算机来说都是一样的，唯一不同的是需要计算机上有 JVM ，它知道如何把中间语言翻译成你的计算机能明白的指令
        - 所以不管是 MacOS、Windos、Linux 只要有 JVM 就能运行同一个中间代码
        - 在安装 Eclipse 时会让你安装一个叫 Java run-time （ Java 运行环境 ）的东西，他就是为你的计算及提供 JVM 的

### 面向对象
- **面向对象**说白了就是程序由一堆**类**组成
- **类** 就是对一些程序 **行为** 和 **数据** 的封装
- 父类一般化，子类继承父类的基本功能，并进行扩展 （ SuperKarel 具有 Karel 的所有功能，还扩展了 右转 和 向后转 的功能 ）
- 类 与 实例 ： 实例被称为对象，类是对象的模板
- 我们开始学习 Java 时，是从别人写好的一些框架类库开始，使得我们在一开始就能写一写很强大的程序
- 展示了 ACM 程序框架（ 由美国计算协会提供 ）
    ```java
    import acm.graphics.*;
    import acm.program.*;

    // 意思是给我一个 GLabel 对象
    new GLabel();
    ```
- 