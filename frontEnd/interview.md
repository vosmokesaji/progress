FrontEnd Interview

# PLAN
- [ES6](http://es6.ruanyifeng.com/#README) 周一，周二两天
- [VUE](https://cn.vuejs.org/v2/guide/) [面试题](https://juejin.im/post/5d218f6751882579d9188eeb?utm_source=gold_browser_extension)  周三周四两天
- [webpack](https://www.webpackjs.com/concepts/) 周五一天
- [网络知识](https://juejin.im/post/5c591fda6fb9a049dc02b1cc)、[这些](https://juejin.im/search?query=%E5%89%8D%E7%AB%AF%20%E7%BD%91%E7%BB%9C&type=all)、[布局](https://juejin.im/post/5b3b56a1e51d4519646204bb)  周末

# Point
- CSRF 是啥？

# 直播课程

## 珠峰培训精品公开课：浏览器渲染原理
0. 介绍 
- 真正的前端开发，对js低层，浏览器运行底层，有清楚的了解，写出来的代码在性能、稳定、可扩展性更强，更多大声直接封装底层框架。

1. 浏览器渲染机制
   1. HTTP请求阶段
   2. HTTP响应阶段
   3. 浏览器渲染阶段


2. 阿里经典面试题：DOM重回和回流



3. 阿里九段人才培养方案



4. 当下前端开发工程师需要掌握的技术栈



5. 给自学者的建议




## andorcba
重要的放上面：
	https://coding.imooc.com/class/190.html
	我在慕课上买的课要看就用我的微信登录

项目
	技术栈
	业务深度
	成长

webpack 分包优化 性能优化
es6
	箭头函数的作用
	扩展符的应用(...)
	promise
		实现原理    https://www.jianshu.com/p/b4f0425b22a1
		解决了什么问题  https://blog.csdn.net/weixin_34114823/article/details/88741050
	什么是事件循环   https://www.jianshu.com/p/8df1d01b33dc
	什么是宏任务和微任务  https://www.jianshu.com/p/8df1d01b33dc
	Async wait / promise区别    http://caibaojian.com/asyncawait.html
	Class的实现原理   https://segmentfault.com/a/1190000008390268?utm_source=tag-newest

vue
	组件间通信(子-父，父-子，兄弟间)
	computed watch差别
	keep-alive生命周期activated和deactivated的理解
	vuex 的api及使用场景
	vuex中actoin和mutation的差别
	vue-router钩子函数
	如何封装组件
	snabodom的核心方法
	MVVM的理解  https://coding.imooc.com/class/190.html
	什么是虚拟DOM  https://coding.imooc.com/class/190.html
	vue如何双向绑定 ：definePropoty + 订阅式  https://coding.imooc.com/class/190.html
	vue性能为何高于jQuery?
原生JS
	如何实现原型继承
	内存泄漏 
	回收机制 
	闭包 
	call apply使用场景
	判断数组方法
	数组的常用方法
	jQuery实现原理   https://www.jianshu.com/p/ca9825766db3
	弱类型间的转换
	设计模式  https://www.jianshu.com/p/4b110e4c3bcd
		工厂模式
		构造函数模式
		原型模式
		单例模式
		发布者模式 + 订阅者模式
		观察者模式
	requestAnimationFrame  与 setTimeout 差别
	ajax实现原理
	0.1+0.2>0.3  成立吗？为什么


浏览器知识
	浏览器解析原理  https://blog.csdn.net/riddle1981/article/details/78681191
	跨域解决办法 https://segmentfault.com/a/1190000015597029
	什么是同源策略
	v8是什么
	浏览器内核种类
	回流和重绘  https://segmentfault.com/a/1190000014474575
	性能优化相关
	存储   https://www.jianshu.com/p/03a38b56bdd7
		localstorage
		sessionstorage
		cookie
		user data
		以上的区别
	缓存    https://www.jianshu.com/p/54cc04190252
		物理缓存
		内存缓存
		强缓存缓存
		以上的区别
相关知识
	7层网络协议   https://blog.csdn.net/taotongning/article/details/81352985
	http协议 及 https相关知识理解   https://www.jianshu.com/p/6db0c6dc97a9
	http code码   https://blog.csdn.net/qq_35779969/article/details/80753197
算法、数据结构
	快排 
	冒泡
	生成一个任意区间的随机数
	url字典对象    https://blog.csdn.net/redtopic/article/details/69396908
	实现抽奖 ： 尽可能实现一个均匀的正态分布：每一百次中 一等奖1个 二等奖10个三等奖20 剩余未中奖
	什么是堆和栈    https://blog.csdn.net/flyingpig2016/article/details/52895620
	直接类型和引用数据类型的区别  https://www.cnblogs.com/chunyi/p/10281750.html

页面类
	rem布局h5中设置基础的font-size是如何换算的  https://www.jianshu.com/p/04efb4a1d2f8
	webp是什么
动画/css
	transtion 和 transform的应用场景和差别  https://segmentfault.com/a/1190000016666601
	如何开启GPU加速  https://blog.csdn.net/hsany330/article/details/50925260

概念性
	什么是工程化 模块化 组件化   https://www.jianshu.com/p/8cad6f0b94b3
	amd、cmd、commonjs规范 区别及应用   https://www.cnblogs.com/jiuyi/p/9181259.html
	前端语义化   https://www.jianshu.com/p/81b264b179bf
	行为结构表现分离



相关资料：
1. JS ES6语法: 1. var let const区别（https://baijiahao.baidu.com/s?id=1621787284851612777）。 
2. 箭头函数相关（包括里面的this等）（https://www.cnblogs.com/fundebug/p/6904753.html、https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001438565969057627e5435793645b7acaee3b6869d1374000、https://blog.csdn.net/hqh642134542/article/details/78809951）3. Promise原理（https://baijiahao.baidu.com/s?id=1596005633332556077）
2. 网络方面：1. 网络7层协议（https://www.cnblogs.com/qishui/p/5428938.html、https://blog.csdn.net/cmyh100/article/details/82768804） 2. xhr(http://www.cnblogs.com/xiaohuochai/p/6036475.html)以及fetch(https://www.jianshu.com/p/35123b048e5e) 3. 跨域(https://segmentfault.com/a/1190000015597029) 4. HTTP code(https://blog.csdn.net/qq_35779969/article/details/80753197)
3. 浏览器相关：1. 缓存原理（https://www.cnblogs.com/shixiaomiao1122/p/7591556.html） 2. 从访问一个URL到用户看见页面之间所有的过程（https://www.jianshu.com/p/01d25c206fab） 3. 浏览器渲染原理（JS引擎，CSS引擎等）(https://blog.csdn.net/riddle1981/article/details/78681191)
4. 性能方面：https://www.jianshu.com/p/a29aadf28a9e
5. 组件方面：http://web.jobbole.com/92879/、https://www.cnblogs.com/kuailingmin/p/4205724.html
6. 工程化：https://www.cnblogs.com/fsyz/p/8274727.html、https://www.imooc.com/article/48008
7. 面向对象方面：https://blog.csdn.net/jsnancy/article/details/80357188、https://www.cnblogs.com/chenhuichao/p/8202588.html
8. 观察者模式：https://www.cnblogs.com/gradolabs/p/4786782.html

https://www.cnblogs.com/c2016c/articles/9328725.html
https://www.cnblogs.com/le220/p/8624905.html
https://www.jianshu.com/p/deceb72e13b3
https://www.jianshu.com/p/deceb72e13b3
https://www.cnblogs.com/minigrasshopper/p/9134196.html
https://blog.csdn.net/wulex/article/details/81774494  https://www.jianshu.com/p/eef79060d486  https://www.cnblogs.com/hahazexia/p/8691052.html  理解call apply bind
https://blog.csdn.net/MingL520/article/details/88549999    面试题汇总
https://www.jianshu.com/p/0d50ea1cef93?utm_source=oschina-app   vue声明周期
https://www.cnblogs.com/jiasm/p/9482443.html    微任务、宏任务
https://www.jianshu.com/p/df198914331b  vue首屏加载优化


# 慕课前端面试课


## ES6 语法

- 开发环境已经普及使用
- 浏览器确支持不好（需要开发环境编译）
- es6 内容很多，重点了解常用语法
- 面试： 开发环境的使用 + 重点语法的掌握

### 问题
- ES6 模块化如何使用，开发环境怎么打包
- Class 和普通构造函数有何区别
- Promise 的基本使用和原理
- 总结一下 ES6 的常用功能

### 模块化

1. 模块化 - 语法
```javascript
/* util1.js */
export default {
    a: 100
}

/* util2.js */
export function fn1() {
    alert("fn1");
}
export function fn2() { 
    alert("fn2");
}

/* index.js */
import util1 from './util1.js';
import { fn1, fn2 } from './util2.js';
console.log(util1);
fn1();
fn2();

// 如果用的是 export default ，引入的时候直接 import 就行
// 如果是 export 好几个，引入的时候要用大括号括起来，像这样  { fn1, fn2 } ，哪怕只有一个也要放在大括号里  { fn1 } 
```

2. ES6 语法解析： babel
- 电脑中要有 node 环境， 运行 
    ```shell
    npm init
    # 或者
    npm init -y

    # 安装 babel
    npm install --save-dev babel-core babel-preset-es2015 babel-preset-latest
    # 或者这样  （ 注_001 ） 
    npm install --save-dev babel-core babel-preset-es2015 babel-preset-latest --registry=https://registry.npm.taobao.org
    
    # 创建 .babellrc 文件
    touch .babelrc

    # 全局安装 babel-cli （ mac 全局安装需要 sudo ； windows 全局安装需要以管理员身份运行命令行工具 ，再执行这个）
    npm install -global babel-cli

    # 看 babel 是否安装成功
    babel --version
    ```
- 创建 index.js 
    ```javascript
    [1, 2, 3].map(item => item + 1);
    ```
- 编译 index.js
    ```shell
    babel index.js
    ```
- 注_001：这里安装的时候为了快，可以走[国内镜像](https://npm.taobao.org)
- .babelrc 文件的内容： ```"es2015", "latest"``` 是我们刚刚安装两个插件的别名， ```"plugins"``` 是插件，暂时不用
    ```json
    {
        "presets": ["es2015", "latest"],
        "plugins": []
    }
    ```
- .babelrc 不用太详细的了解，是 #$%^&*()*&^% (记助攻对 的一部分？ 没听清)

3. 打包工具： webpack 
- 安装
    ```shell
    # 建议在项目内安装 webpack 
    npm webpack babel-loader --save-dev
    ```
- webpack 配置文件 webpack.config.js
    ```javascript
    module.export = {
        entry: "./src/index.js",
        output: {
            path: __dirname,
            filename: "./build/bundle.js"
        },
        module: {
            rules: [{
                test: /\.js?$/,
                exclude: /(node_modules)/,
                loader: "babel-loader"
            }]
        }
    }
    ```
- 配置 package.json 中的 ```scripts``` 
    ```json
    "scripts": {
        "start": "webpack"
    }
    ```
- 运行 ```npm start``` 其实就相当于运行 ```"scripts"``` 里 ```"start"``` 对应的 ```"webpack"``` 
- webpack 会根据我们配置好的 webpack.config.json 进行打包
- 打包完之后，可以测试一下：
    1. 创建一个 index.html ，引入 src/bundle.js 
    2. 开启服务：命令行在 index.html 所在目录运行 ```http-server -p 8881```
    3. 浏览器访问 [localhost:8881/index.html](http://localhost:8881/index.html)
    4. 会看到 页面 alert 了 fn1 fn2 ，控制台输出了 ```{a: 100}``` ， 说明 util1 和 util2 都被 webpack 打包到了 bundle.js 中了

4. rollup
- vue 和 React 框架都是通过 [rollup](https://rollupjs.org/guide/zh/) 打包的 （这里是[英文网站](https://rollupjs.org/guide/en/)）
- 重新搞一个文件夹，来学习 rollup 
    ```shell
    mkdir learnRollup && cd learnRollup
    npm init 

    # 安装 rollup 以及 rollup 需要的一些工具
    npm install rollup rollup-plugin-node-resolve rollup-plugin-babel babel-plugin-external-helpers babel-preset-latest babel-core --save-dev
    
    # 创建 .babelrc
    touch .babelrc

    # 创建 rollup 配置文件
    touch rollup.config.js
    ```
- .babelrc 的内容
    ```json
    {
        "presets": [
            ["latest", {
                "es2015": {
                    "modules": false
                }
            }] 
        ],
        "plugins": ["external-helpers"]
    }
    ```
    - 不一样的地方： ```"modules": false``` 意思是我们不关心引入的第三方插件， ```"external-helpers"``` 因为 rollup 使用 babel 的时候依赖这么一个插件
- rollup.config.js 的内容
    ```javascript
    // 引入 babel 和 resolve 这两个插件
    import babel from "rollup-plugin-babel";
    import resolve from "rollup-plugin-node-resolve";

    export default {
        entry: "./src/index.js",        // 入口文件
        format: "umd",                  // 格式： umd 意思是即兼容 直接引入页面中的 js ，也兼容 CommenJS ， 也兼容 AMD
        plugins: [
            resolve(),
            babel({
                exclude: "node_modules/**"
            })
        ],
        dest: "build/bundle.js"
    }
    ```

- 将 webpack 环境的代码拷贝过来
- 修改 package.json 的 ```scripts``` 
    ```json
    "scripts": {
        "start": "rollup -c rollup.config.js"
    }
    ```
- 运行 ```npm start``` 
- 将打包的结果对比 webpack ，我们发现：
    1. rollup 打包的代码跟简洁，冗余代码更少，基本和源码一样，方便调试
    2. rollup 打包的文件体积比 webpack 的要小


5. rollup 对比 webpack
- rollup 功能单一 （专注打包）， webpack 功能强大（学习成本很高）
- 参考设计原则和《Linux/Unix设计思想》，这两本书都提到了 “单一值原则” ，一个东西做好一件事儿就好了
- 工具要劲量功能单一，可集成，可扩展
- wangEditor 用的 gulp + rollup （ [wangEditor](https://github.com/wangfupeng1988/wangEditor) 是作者的一个开源项目）


6. 总结 关于 JS 众多模块化标准
- 没有模块化的时候，代码冗余严重
- AMD 成为**标准**， require.js （也有 CMD ，用的不是特别多）
- 前端打包工具，grunt -> gulp -> webpack  ， nodejs 模块也可以被使用
- ES6 出现，想统一现在所有模块化的标准
- nodejs 积极支持，浏览器尚未统一
- 你可以自造 lib ， 但是不要自造标准！！！

7. 总结 & 问题解答
- 语法： import export （ 注意有无 default ）
- 环境：babel 是用来编译 ES6 语法的， 模块化可以用 webpack 和 rollup 
- 扩展：说一下自己对模块化标准统一的期待


### Class

> 2-9 开始于 3点20  开会浪费了半个小时

#### Class 和 普通构造函数有何区别
- JS 构造函数 
- Class 基本语法
- 语法糖
- 继承 


1. JS 构造函数
    ```javascript
    function MathHandle(x, y){
        this.x = x;
        this.y = y;
    }

    MathHandle.prototype.add = function(){
        return this.x + this.y;
    };

    var m = new MathHandle(1, 2);
    console.log(m.add());
    ```

2. Class基本语法
    ```javascript
    class MathHandle {
        // constructor 是一个构造器，相当于构造函数
        constructor(x, y) {
            this.x = x;
            this.y = y;
        }

        // 相当于在原型中定义的方法
        add(){
            return this.x + this.y;
        }
    }

    const m = new MathHandle(1, 2);
    console.log(m.add());

    typeof MathHandle;   // "function"
    MathHandle === MathHandle.prototype.constructor;    // true

    // 实例的 隐式原型 等于 构造函数的 显式原型
    m.__proto__ === MathHandle.prototype;       // true
    ```

3. 语法糖 （这两种写法，本质是一样的， calss 相当于语法糖，书写更加简单，更方便从后端转前端的开发）
    ```javascript
    class MathHandle {}

    typeof MathHandle;   // "function"
    MathHandle === MathHandle.prototype.constructor;    // true
    m.__proto__ === MathHandle.prototype;       // true

    // 这种语法糖形式，看起来和实际原理不一样的东西，视频老师个人不太赞同
    // 形式上强行模仿 java C# ， 却失去了它的本性和个性
    ```
4. class 继承
- 回顾一下 JS 的继承
    ```javascript
    // 动物
    function Animal(){
        this.eat = function(){
            console.log("animal eat");
        }
    }

    // 狗
    function Dog(){
        this.bark = function(){
            console.log("dog bark");
        }
    }

    // 绑定原型，实现继承 （这里视频的老师没有将 构造函数 重新指向 Dog ，应该是要有这么一步的）
    Dog.prototype = new Animal();

    // 实例化 哈士奇
    var hashiqi = new Dog();
    ```

- class 继承
    ```javascript
    class Animal {
        constructor(name){
            this.name = name;
        }

        eat(){
            console.log(this.name + "eat");
        }
    }

    class Dog extends Animal {
        constructor (name){
            // 注意 ！！！ 只要这个 class 有 extends 就得败 super 写上
            // super(name) 相当于执行了被继承的 class 的 constructor ，并且把 name 传了进去
            super(name);
            this.name = name;
        }

        say(){
            console.log(`${this.name} say`);
        }
    }

    const dog = new Dog("哈士奇");
    dog.say();
    dog.eat();
    ```
- class 写继承 相较于 构造函数的继承，可读性更强，更方便初学者   

5. 总结
- Class 在语法上更加贴合面向对象的写法
- Class 实现继承更加易读、易理解
- 更易于写 java 等后端语言的使用
- **本质**还是语法糖，使用 prototype 
- 所有的语法糖都需要了解本质

### Promise 
- Callback Hell (回调地狱)
    ```javascript
    function loadImg(src, callback, fail){
        var img = document.createElement("img");
        img.onload = function(){
            callback(img);
        }
        img.onerror = function(){
            fail();
        }
        img.src = src;
    }

    var src = "https://www.imooc.com/static/img/index/logo.png";
    loadImg(src, function(img){
        console.log(img.width);
    }, function(){
        console.log("failed")
    });
    ```
- Promise 语法
    ```javascript
    function loadImg(src){
        // 创建 Promise 实例
        // resolve （解决） 和 reject  （拒绝） 都是函数，分别是成功和失败的回调
        const promise = new Promise(function(resolve, reject){
            var img = document.createElement("img");
            img.onload = function(){
                resolve(img);
            }
            img.onerror = function(){
                reject("图片加载失败");
            }
            img.src = src;
        });

        // return Promise 实例
        return promise;
    }

    // 使用
    var src = "https://www.imooc.com/static/img/index/logo.png"
    var result = loadImg(src);

    // 第一个 function : 成功的回调， 第二个 function ： 失败的回调
    result.then(function(img){
        console.log(img.width);
    }, function(){
        console.log("failed");
    })

    // 一个 Promise 对象可以分开处理不同的事件
    result.then(function(img){
        console.log(img.height);
    });

    // 多个 then 可以处理不同的回调，一次干多件事儿 
    ```
- 小结一下 Promise 的用法：
    - 创建 Promis 实例，传入一个回调函数，函数要有 resolve 和 reject 这两个参数
    - 在这个回调函数里你可以定义什么情况执行 resolve （一般是成功）， 什么情况执行 reject （一般是失败）
    - 使用 Promise 实例的 .then() 监听结果，处理相应的 成功回调 或者 失败回调




### ES6 其他常用功能

#### let/const
    - let 定义变量
    - const 定义常量（只能赋值一次，再次赋值会报错）
    ```javascript
    // JS
    var i = 10;
    i = 100;
    var j = 10;
    j = 100;

    // ES6
    let i = 10;
    i = 100;        // 正常
    const j = 10;
    j = 100;        // 报错
    ```
#### 多行字符 / 模板字符串 （都得用反引号）
    ```javascript
    // JS
    var name = "Tom", age = 10, html = "";
    html += "<div>";
    html += "<p>" + name + "</p>";
    html += "<p>" + age + "</p>";
    html += "</div>";

    // ES6
    const name = "Tom", age = 10;
    const html = `<div>
                    <p>${name}</p>
                    <p>${age}</p>
                  </div>`;
    ```
#### 解构赋值
    ```javascript
    // JS
    var obj = {a: 100, b: 200, c: 300};
    var a = obj.a;
    var c = obj.c;

    var arr = ["xxx", "yyy", "zzz"];
    var x = arr[0];

    // ES6
    const obj = {a: 100, b: 200, c: 300};
    // 解构赋值的时候变量名必须和对象的 Key 一致才能赋值
    const {a, c} = obj;
    console.log(a);         // 100
    console.log(c);         // 300

    const arr = ["xxx", "yyy", "zzz"];
    // 数组的解构赋值是按顺序来的， 如果被赋值的变量多于数组的长度， 多出来的变量为 undefined
    const [x, y, z] = arr;
    console.log(x);         // "xxx"
    console.log(y);         // "yyy"
    console.log(z);         // "zzz"
    ```
#### 块级作用域（ 在代码块 ```{}``` 中声明的变量，在块外访问不到 ）
    ```javascript
    // JS
    var obj = {a: 100, b: 200, c: 300};
    for(var item in obj){
        console.log(obj[item]);
    }
    console.log(item);      // "c"

    // ES6
    var obj = {a: 100, b: 200, c: 300};
    for(let item in obj){
        console.log(obj[item]);
    }
    console.log(item);      // undefined
    ```
#### 函数默认参数
    ```javascript
    // JS
    // 如果没有传 b ，那 b 的值为 0
    function (a, b) {
        if(b == null){
            b = 0;
        }
    }

    // ES6
    function (a, b = 0){

    }
    ```
#### 箭头函数
    ```javascript
    // JS
    var arr = [1, 2, 3];
    arr.map(function(item){
        return item + 1;
    })

    // ES6
    var arr = [1, 2, 3];

    // 如果函数只有一个参数，并且函数体制有一行的话 可以这么写
    arr.map(item => return item + 1);

    // 如果函数不止一个参数，要把参数用括号包起来
    arr.map((item, index) => {
        console.log(index);
        return item + 1;
    })
    ``` 
#### 箭头函数 特别重要的特点：
    ```javascript
    function fn(){
        console.log("real", this);
        var arr = [1, 2, 3];

        // JS
        arr.map(function(item){
            console.log("JS", this);
            return item + 1;
        })

        // ES6
        arr.map(item => {
            console.log("ES6", this);
        })
    }
    fn.call({a: 100});
    ``` 

> 这些功能要么是解决了 JS 的问题，要么是让写法更简洁，容易阅读容易理解


## 原型
> Tips: 使用 zepto 和 jquery 讲原型，也算顺便解读了这二者的源码
- 问题 
    1. 说一个原型的实际应用
    2. 原型如何实现它的扩展性

- jquery 和 zepto 的简单应用
    - zepto 如何使用原型
    - jquery 如何使用原型

    ```html
    <p>jquery test 1</p>
    <p>jquery test 2</p>
    <p>jquery test 3</p>

    <div id="div1">
        <p>jquery test in div</p>
    </div>

    <script src="./jquery.3.2.1.js"></script>
    <script>
        var $p = $("p");
        $p.css("font-size", "40px");

        // 对这 4 个元素输出 html() 的时候，只会输出第一个，这是 jquery api 的规定
        console.log($p.html());             // jquery test 1

        var $div1 = $("#div1");
        $div1.css("color", "blue");
        console.log($div1.html());          // <p style="font-size: 40px;">jquery test in div</p>
    </script>
    ```
- 当多个实例可以使用一套方法时（ 像 ```css()``` 和 ```html()``` 这样的方法 ），说明，方法是来自于一个函数的原型当中

### 实际应用 - zepto 如何使用原型
    ```javascript
    // 空对象
    var zepto = {};

    zepto.init = function(selector){
        // 源码中，这里的处理情况比较复杂，但因为这次只针对原型，所以这里就做了一点儿简化
        var slice = Array.prototype.slice;
        var dom = slice.call(document.querySelectorAll(selector));
        return zepto.Z(dom, selector);
    }

    // 即使用 zepto 时候的 $
    var $ = function(selector){
        return zepto.init(selector);
    }

    // 这是 构造函数
    function Z(dom, selector){
        var i, len = dom ? dom.length : 0
        for(i = 0; i < len; i++){
            this[i] = dom[i];
            this.length = len;
            this.selector = selector || "";
        }
    }
    
    zepto.Z = function(dom, selector){
        // 注意， 出现了 new 关键字
        return new Z(dom, selector);
    }

    // 原型
    $.fn = {
        constructor: zepto.Z,

        css: function(key, value){
            alert("css");
        },
        html: function(value){
            return "this is html function";
        }
    }

    zepto.Z.prototype = Z.prototype = $.fn;

    window.$ = $
    ```

### 实际应用 - jQuery 如何使用原型
    ```javascript
    // 定义构造函数
    var init = jQuery.fn.init = function(selector){
        var slice = Array.prototype.slice;
        var dom = slice.call(document.querySelectorAll(selector));

        var i, len = dom ? dom.length : 0;
        for(i = 0; i < len; i++){
            this[i] = dom[i];
        }
        this.length = len;
        this.selector = selector || "";
    }

    // 初始化 jQuery.fn
    jQuery.fn = jQuery.prototype = {
        constructor: jQuery,

        // 其他函数...
        css: function(key, value){
            alert("css");
        },
        html: function(value){
            return "this is html function";
        }
    }

    // 定义原型
    init.prototype = jQuery.fn;

    var jQuery = function(selector){
        return new jQuery.fn.init(selector);
    }

    ```
### 问题解答
- 描述一下 jQuery 如何使用原型
- 描述一下 zepto 如何使用原型
- 自己的项目经验中哪些用到了原型

### 如何体现原型的扩展性
- 总结 jQuery 和 zepto 原型的使用
- 插件机制 

1. 在 zepto 实现中：
    ```javascript
    $.fn = {
        constructor: zepto.Z,

        css: function(key, value){
            alert("css");
        },
        html: function(value){
            return "this is html function";
        }
    }

    zepto.Z.prototype = Z.prototype = $.fn;
    ```
    - 这段代码，为啥不把 这个对象直接赋值给 ```Z.prototype``` 而要通过 ```$.fn``` ？
2. jQuery 的实现中：
    ```javascript
    jQuery.fn = jQuery.prototype = {
        constructor: jQuery,

        // 其他函数...
        css: function(key, value){
            alert("css");
        },
        html: function(value){
            return "this is html function";
        }
    }

    init.prototype = jQuery.fn;
    ```
    - 与 zepto 同样的疑问，为啥会有 ```jQuery.fn``` 这个东西？
3. 答案就是 **因为要扩展插件**， 做一个简单的插件的例子
    ```javascript
    $.fn.getNodeName = function(){
        return this[0].nodeName;
    }
    ```
    - 好处1：只有 ```$``` 会暴露在 ```window``` 全局变量（一个库暴露给全局一个变量就好了）
    - 好处2：将插件扩展统一到 $.fn.xxx 这一个接口，方便使用（封装插件的一个思想）

4. 问题解答：原型怎么扩展
    - 先说一下 jQuery 和 zepto 的插件机制
    - 结合自己的开发经验，做过的基于原型的插件

5. Tips: 为啥讲 jQuery 和 zepto 这些老掉牙的东西？
    - 不要以为 react 、 vue 已经一统天下了，这种观念是非常错误的
    - 你可以看看 npm 上 jQuery（周下载量259w） 和 [vue](https://www.npmjs.com/package/vue)（周下载量 100w） 下载量的对比，最起码jquery 还没有那么过时。
    - 而且很多 jquery 的引用是直接通过 cdn 引入的，拿来就能用

 

## 异步

- 什么是单线程？和异步有什么关系？ 
- 什么是 event-loop ？
- 是否用过 jQuery 的 Deferred 
- Promise 的几本使用和原理
- 介绍一下 Async/Await （和 Promise 的区别、联系）
- 总结一下当前 JS 解决一步的方案


### 单线程、异步
- 单线程 - 只有一个线程，**同时只能只做一件事儿**
- 原因 - 为了避免 DOM 渲染的冲突
- 解决方案 - 异步

1. 单线程
    ```javascript
    // 循环运行期间，后边 JS 执行和 DOM 渲染会暂时卡顿
    var i, sum = 0;
    for(i = 0; i < 100000000; i++){
        sum += 1;
    }
    console.log(sum);

    // 如果放着 alert 不处理， 那么 JS 的执行和 DOM 渲染会暂时卡顿
    console.log(1);
    alert("hello");
    console.log(2);
    ```
2. 原因 - 为了避免 DOM 渲染的冲突
- 浏览器需要渲染 DOM 、 JS 可以修改 DOM 结构
- JS 执行的时候，浏览器渲染 DOM 会暂停
- 两段 JS 也不能同时执行
- H5 中有个 webworker 支持多线程，但是不能访问 DOM

3. 解决方案 - 异步
    ```javascript
    console.log(100);
     setTimeout(function(){         // setTimeout 是异步的
         console.log(200);          // 反正 1000ms 之后执行
     }, 1000);                      // 先不管它，先让其他 JS 代码运行
     console.log(300);
     console.log(400);


    // ajax
    console.log(100);
    $.ajax({
        url: "xxx",
        success: function(){
            console.log(result);
        }
    })
    console.log(300);
    console.log(400);
    ```

4. 异步 - 小结
    - 异步会导致的问题一： 没有按照代码书写顺序执行，可读性差
    - 异步会导致的问题二： callback 中不容易模块化

5. 问题解答： **什么是单线程？和异步有什么关系？**
    - 单线程就是同一时间只能做一件事儿，两段js不能同时执行
    - 原因就是为了避免 DOM 渲染的冲突
    - 异步是一种 “无奈” 的选择，虽然有很多问题

### 什么是 event-loop
- 单线程 - 同一时间只能做一件事儿
- 原因 - 避免 DOM 渲染的冲突
- 解决方案 - 异步
- **异步的实现方式 - event loop**
- 什么是 **event loop**
    1. 也叫事件轮询，是 JS 实现异步的**具体解决方案**
    2. 同步的代码，直接在主进程（or 线程？）中执行
    3. 异步函数先放在 **异步队列** 中（如果有延时就延时放在异步队列中）
    4. 待同步代码执行完毕， **轮询执行** 异步队列代码

    ```javascript
    // 实例分析 1
    setTimeout(function(){
        console.log(100);
    }, 100);
    console.log(200);

    // 以下是对这段代码的分析
    // 主进程
    console.log(200);

    // 异步队列
    function(){
        console.log(100);
    }
    ```

    ```javascript
    // 实例分析 2
    setTimeout(function(){
        console.log(11);
    }, 100);
    setTimeout(function(){
        console.log(2);
    });
    console.log(3);

    // 以下是对这段代码的分析
    // 主进程
    console.log(3);

    // 异步队列
    // 立刻被放入
    function(){
        console.log(2);
    }

    // 100ms 后被放入
    function(){
        console.log(1)
    }
    ```

    ```javascript
    // 实例分析 3
    $.ajax({
        url: "xxx",
        success: function(){
            console.log('a');
        }
    });
    setTimeout(function(){
        console.log('b');
    }, 100);
    setTimeout(function(){
        console.log('c');
    });
    console.log('d');

    // 以下是对这段代码的分析
    // 下边的三个执行顺序和 实例2 一样

    // ajax 请求成功的时间不定，
    // 如果 ajax 请求成功的时间小于100ms ，
    function(){
        console.log('a');
    }
    // 会先于
    function(){
        console.log('b');
    }
    // 被放到异步队列中
    // 结果是 d c a b

    // 如果 ajax 请求成功的时间大于100ms ，结果是 d c b a
    ```

### jQuery 的 Deferred
- jQuery 1.5 的变化
- 使用 jQuery Deferred
- 初步引入 Promise 概念


- jQuery 1.5 之前
    ```javascript
    var ajax = $.ajax({
        url: "data.json",
        success: function(){
            console.log("success1");
            console.log("success2");
            console.log("success3");
        },
        error: function(){
            console.log("error");
        }
    })
    console.log(ajax);  // 返回一个 XHR 对象
    ```
- jQuery 1.5 之后
    ```javascript
    var ajax = $.ajax("data.json");
    ajax.done(function(){
            console.log("success1");
        })
        .fail(function(){
            console.log("error");
        })
        .done(function(){
            console.log("success2");
        })
    })
    console.log(ajax);  // 返回一个 deferred 对象

    // 还可以这么写 ， 很像 Promise 的写法
    var ajax = $.ajax("data.json");
    ajax
    .then(function(){
        console.log("success1");
    }, function(){
        console.log("error1");
    })
    .then(function(){
        console.log("success2");
    }, function(){
        console.log("error2");
    })
    ```
- Promise 是在 2015 年被加入 ES6 标准的， jquery 的 Deferred 早在1.5 的时候就有这种写法了
- jQuery 1.5 的变化
    1. 无法改变 JS 异步和单线程的本质
    2. 只能从写法上杜绝 callback 这种形式
    3. 它是一种语法糖形式，但是**解耦**了代码
    4. 很好的提现了： 开放封闭原则（对扩展开放，对修改封闭）
    
> 23种设计模式，5个设计原则
- 开放封闭原则：
    - 对多人维护有好处，你不改我的代码，我也不改你的代码，要修改的话扩展就可以了；
    - 对测试回归也有好处，如果你要修改原来的代码，测试就要通通回归一遍，如果是扩展的代码，只要测试扩展的部分就行。大大减少了回归测试的成本

#### Deferred 应用
    ```javascript
    // 给出一段非常简单的异步代码，使用 setTimeout 函数
    var wait = function(){
        var task = function(){
            console.log("执行完成！");
        }
        setTimeout(tast, 2000);
    }
    wait();

    // 新增需求： 要在执行完成之后 进行某些特别复杂的操作，代码可能会很多。而且分好多步骤
    // 使用 jQuery Deferred
    function waitHandle(){
        var dtd = $.Deferred();

        var wait = function(_dtd){       // 要求传入一个 deferred 对象
            var task = function(){
                console.log("执行完成")；
                _dtd.resolve();      // 表示异步任务已经完成
                // dtd.reject();       // 表示异步任务失败或出错
            }
            setTimeout(task, 2000);
            return _dtd;            // 要求返回 deferred 对象
        }

        // 注意：这里一定要有 返回值
        return wait(dtd);
    }

    var w = waitHandle()
    w.then(function(){
        console.log("OK 1");
    }, function(){
        console.log("error 1");
    })
    .then(function(){
        console.log("OK 2");
    }, function(){
        console.log("error 2");
    })

    // 开放封闭原则
    // 如果有很多的处理逻辑，可以分好几个 then 来写
    // 这就是 对扩展开放 ， 对修改封闭
    // 如果你要新增别的逻辑，可以新增 .then (修改bug 和 完善现有逻辑除外)
    ```
- dtd 的 API 可以分为两类，用意不同
- 第一类： ```dtd.resolve()   dtd.reject()``` ，用来决定成功 or 失败
- 第二类： ```dtd.then()  dtd.done()  dtd.fail()``` ， 用来执行成功 or 失败的处理逻辑
- 这两类应该分开，否则后果很严重！
- 【测试】可以在上边的代码最后执行 dtd.reject() 试一下后果
- 怎么解决这个问题呢？
    ```javascript
    function waitHandle(){
        var dtd = $.Deferred();
        var wait = function(_dtd){
            var task = function(){
                console.log("执行完成")；
                _dtd.resolve();
            }
            setTimeout(task, 2000);

            // 注意：这里不返回 deferred 对象 ，而是返回 promise 
            return _dtd.promise();
        }

        return wait(dtd);
    }


    // 经过上边的改动， w 接收的就是一个 promise 对象
    var w = waitHandle()
    $.when(w)
    .then(function(){
        console.log("OK 1");
    }, function(){
        console.log("error 1");
    })
    .then(function(){
        console.log("OK 2");
    }, function(){
        console.log("error 2");
    })

    // w.reject();    // 执行这句话会报错
    // 返回的 promise 对象通过 $.when() 封装后只有 .then()  .done()  .fail() 这些方法
    ```
#### 问题解答
- jQuery 1.5 前后的 ajax 改变举例
- 说明如何简单封装，使用 Deferred （最好提及 开放封闭原则）
- 说明 promise 和 Deferred 的区别
    - Deferred 对象有 reslove reject 这种主动触发的函数，也有 then done fail 这种被动监听的函数，这些函数都能被访问是不行的，容易被滥用
    - 通过生成一个 promise 对象类隔离， promise对象只能被动监听
> 想深入理解它，就需要知道它的前世今生。
> 老师很反感新概念直接填鸭式的告诉你怎么用。
> 比如你想了解计算机，你要先了解计算机的历史：从图灵机开始，什么是图灵完备。。。


### Promise 的基本使用和原理
#### 基本语法回顾
    ```javascript
    function loadImg(src){
        // 创建 Promise 实例
        // resolve （解决） 和 reject  （拒绝） 都是函数，分别是成功和失败的回调
        const promise = new Promise(function(resolve, reject){
            var img = document.createElement("img");
            img.onload = function(){
                resolve(img);
            }
            img.onerror = function(){
                reject("图片加载失败");
            }
            img.src = src;
        });

        // return Promise 实例
        return promise;
    }

    // 使用
    var src = "https://www.imooc.com/static/img/index/logo.png"
    var result = loadImg(src);

    // 第一个 function : 成功的回调， 第二个 function ： 失败的回调
    result.then(function(img){
        console.log(img.width);

        // 如果没有这个 return img ，那第二个 .then 中使用 img 的话会报错 undefined 
        // 这里还有点疑问，有点儿乱。老师讲的上下不一样吗？ 可以看 【Promise 标准】 那一小节，待确定
        // 思考了一下 ，这里用到的返回值是指 img 并不影响下一个 .then 服务的 promise 对象，嗯，应该是这样，还是待确认，待试验。 
        return img;
    }, function(){
        console.log("failed");
    })

    // 一个 Promise 对象可以分开处理不同的事件（可以链式调用）
    result.then(function(img){
        console.log(img.height);
    });

    // 多个 then 可以处理不同的回调，一次干多件事儿 
    ```

> 如果有的老版本浏览器没有支持 ```Promise``` 可以下载 ```bluebird``` 


#### 异常捕获
> 任何程序开发都需要异常捕获，因为一般没法保证程序一定不出问题。不能让程序一出现错误就崩溃吧。程序要有一定的健壮性。
- ```.then()``` 可以接受两个参数，第一个是成功的回调，第二个是失败的回调。
- 但我们如果要进行异常捕获，我们规定：**只给 ```.then()``` 传一个 ```function``` ，最后统一用 ```cache``` 捕获异常**
- 用法：在多个 ```.then()``` 的最后，使用 ```.catch()``` 捕获异常
    ```javascript
    result.then(function(img){
        console.log(img.width);
        return img;
    }).then(function(img){
        console.log(img.height);
    }).catch(function(err){
        // 失败或者 报异常的，我们统一让 catch 去管
        console.log(err);
    })
    ```

#### 多个串联
    ```javascript
    // 需求： 先加载第一个，第一个加载完成再加载第二个。
    var src1 = "https://www.baidu.com/favicon.ico";
    var result1 = loadImg(src1);
    var src2 = "https://www.bilibili.com/favicon.ico";
    var result2 = loadImg(src2);

    // 链式操作
    result1.then(function(img){
        console.log("第一张图片加载完成");

        // 这里是关键
        return result2;
    }).then(function(img){
        // 这个 then 的第一个参数就是 result2 的成功回调
        console.log("第二张图片加载完成")
    }).catch(function(err){
        console.log(err);
    })
    ```



#### Promise.all 和 Promise.race
- ```Promise.all``` 所有请求都完成（all: 全部）
- ```Promise.race``` 第一个请求完成（race: 竞赛，赛跑）
    ```javascript
    // Promise.all 接收一个包含多个 promise 对象的数组
    // 待全部完成之后，统一执行 success
    Promise.all([result1, result2]).then(datas => {
        // 接收到的 datas 是一个数组，依次包含了多个 peomise 返回的内容
        console.log(datas[0]);
        console.log(datas[1]);
    });

    // Promise.race 接收一个包含多个 promise 对象的数组
    // 只要有一个完成，就执行 success
    Promise.all([result1, result2]).then(data => {
        // data 即最先执行完成的 promise 的返回值
        console.log(data);
    });
    ```

#### Promise 标准
- 关于 “标准” 的闲谈
    - 任何技术的 **推广 & 使用** 都需要一套 **标准** 来支撑
    - 如 ```HTML``` ```JavaScript``` ```CSS``` ```HTTP``` 等，无规矩不成方圆
    - **任何不符合标准的东西，终将会被用户抛弃**
    - **不要挑战标准，不要自造标准**
- 状态变化
    - 三种状态： ```pending``` 、 ```fulfilled``` 、 ```rejected```
    - 初始状态是 ```pending```
    - ```pending``` 可以变为 ```fulfilled``` ，或者 ```pending``` 变为 ```rejected```
    - 状态变化不可逆
- then
    - Promise 实例必须实现（这类应该是 **调用** 吧） then 这个方法
    - .then() 可以接收两个函数作为参数，第一个成功回调，第二个失败回调
    - .then() 返回的是一个 Promise 实例 
        - 如果 .then 的回调函数中没有明文返回 promise 实例，那么这个 .then 返回的就是本身的这个 promise 实例，所以我们可以对这个 promise 实例继续 .then
        - 如果 .then 的回调函数返回了另外一个 promise 实例，那后边再执行 .then 的时候，其实执行的是刚刚返回的那个 promise 实例的 .then ）
        ```javascript
        // 两个 then 都是 result 的 then
        var result = loadImg(src);
        result.then(function(img){
            console.log(img.width);
        }, function(){
            console.log("filed")
        }).then(function(img){
            console.log(img.height);
        })

        // 第一个 then 是 result1 的， 因为第一个的回调函数 return 了 result2
        // 所以第二个 then 成为了 result2 的
        result1.then(function(img){
            console.log("第一张图片加载完成");

            // 这里是关键
            return result2;
        }).then(function(img){
            // 这个 then 的第一个参数就是 result2 的成功回调
            console.log("第二张图片加载完成")
        }).catch(function(err){
            console.log(err);
        })
        ```

#### 问题解答
- 基本语法（创建实例，创建的时候定义啥时候成功、啥时候失败；实例 .then .catch）
- 如何捕获异常（ Error 和 reject 都考虑，都可以通过 catch 捕获）
- 多个串联 - 链式执行 
- Promise.all 和 Promise.race
- Promise 标准，状态变化的方向 ， then 函数

### async / await
- Promise 的 then 只是将


## 虚拟 DOM



## MVVM 和 vue



## 组件化和 React



## hybrid



## 总结










# 面试题
1. 观察下边这段代码：
    ```javascript
    var F = function(){}
    Object.prototype.a = function(){ console.log("梧"); }
    Function.prototype.b = function(){ console.log("桐"); }
    var f = new F();
    ```
    问 f 是否可以同时拿到 a 和 b 两个方法？为什么？

2. 写出下面这段函数的输出结果
    ```javascript
    let getNumber = (arg) => {
        return new Promise(function(resolve, reject){
            if(arg <= 10){
                console.log(5);
                showNumber();
                resolve(arg);
            } else {
                console.log(81);
                showNumber();
                reject(arg);
            }
        })
    }
    ```























